<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Rhaki & Rho's Dino">
<title>Rhaki & Rho's Dino Star Catcher!</title>
<!-- Favicon and Apple touch icon: Red Yoshi PNG -->
<link rel="icon" type="image/png" href="apple-touch-icon.png">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    width: 100%;
    height: 100%;
    height: 100dvh;          /* dynamic viewport height ‚Äî shrinks with URL bar */
    overflow: hidden;
    background: #87CEEB;
    font-family: 'Comic Sans MS', 'Chalkboard SE', cursive;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;       /* prevent all browser touch gestures globally */
    overscroll-behavior: none; /* prevent pull-to-refresh / overscroll bounce */
    position: fixed;          /* prevents iOS Safari rubber-banding */
    inset: 0;
  }

  canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
  }

  #start-screen, #win-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
    z-index: 10;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  #win-screen { display: none; }
  #level-screen { display: none; }

  #level-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    transition: background 0.5s;
  }

  .level-title {
    font-size: 58px;
    color: #fff;
    text-shadow: 3px 3px 8px rgba(0,0,0,0.5);
    margin-bottom: 10px;
    text-align: center;
    padding: 0 20px;
    animation: levelPulse 1.5s ease-in-out infinite;
  }

  .level-subtitle {
    font-size: 24px;
    color: rgba(255,255,255,0.9);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    margin-bottom: 30px;
    text-align: center;
    padding: 0 20px;
  }

  @keyframes levelPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  /* Level indicator during gameplay */
  #level-display {
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 20px;
    color: #fff;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    z-index: 5;
  }

  h1 {
    font-size: 52px;
    color: #2E7D32;
    text-shadow: 3px 3px 0 #fff;
    margin-bottom: 10px;
    text-align: center;
    padding: 0 20px;
  }

  .subtitle {
    font-size: 24px;
    color: #555;
    margin-bottom: 30px;
    text-align: center;
    padding: 0 20px;
  }

  .big-dino {
    font-size: 120px;
    margin-bottom: 20px;
  }

  button {
    font-family: 'Comic Sans MS', 'Chalkboard SE', cursive;
    font-size: 32px;
    padding: 15px 50px;
    border: 4px solid #2E7D32;
    border-radius: 20px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
    box-shadow: 0 6px 0 #2E7D32;
    transition: transform 0.1s;
  }

  button:hover {
    transform: translateY(2px);
    box-shadow: 0 4px 0 #2E7D32;
  }

  button:active {
    transform: translateY(4px);
    box-shadow: 0 2px 0 #2E7D32;
  }

  #score-display {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    color: #fff;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    z-index: 5;
  }

  .stars-left {
    position: absolute;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 20px;
    color: #FFD700;
    text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
    z-index: 5;
  }

  #win-screen h1 { color: #FF6F00; }

  .win-msg {
    font-size: 28px;
    color: #333;
    margin-bottom: 20px;
  }

  .confetti {
    font-size: 60px;
    margin-bottom: 20px;
  }

  /* ===== Mobile on-screen controls ===== */
  #mobile-controls {
    display: none;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 160px;
    z-index: 8;
    pointer-events: none;
    padding: 0 15px 15px;
  }

  .ctrl-btn {
    position: absolute;
    pointer-events: auto;
    border: 3px solid rgba(255,255,255,0.5);
    border-radius: 50%;
    background: rgba(255,255,255,0.25);
    color: rgba(255,255,255,0.85);
    font-size: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
  }

  .ctrl-btn:active, .ctrl-btn.pressed {
    background: rgba(255,255,255,0.5);
    border-color: rgba(255,255,255,0.8);
  }

  #btn-left {
    width: 72px; height: 72px;
    left: calc(20px + env(safe-area-inset-left));
    bottom: calc(25px + env(safe-area-inset-bottom));
  }
  #btn-right {
    width: 72px; height: 72px;
    left: calc(110px + env(safe-area-inset-left));
    bottom: calc(25px + env(safe-area-inset-bottom));
  }
  #btn-jump {
    width: 90px; height: 90px;
    right: calc(20px + env(safe-area-inset-right));
    bottom: calc(20px + env(safe-area-inset-bottom));
    font-size: 32px;
    border-radius: 50%;
    background: rgba(76, 175, 80, 0.4);
    border-color: rgba(76, 175, 80, 0.7);
  }
  #btn-jump:active, #btn-jump.pressed {
    background: rgba(76, 175, 80, 0.65);
    border-color: rgba(76, 175, 80, 0.9);
  }

  /* Responsive text for small screens */
  @media (max-width: 600px) {
    h1 { font-size: 32px; }
    .subtitle { font-size: 16px; margin-bottom: 15px; }
    .big-dino { font-size: 80px; margin-bottom: 10px; }
    button { font-size: 24px; padding: 12px 36px; }
    #score-display { font-size: 22px; top: 10px; }
    .stars-left { font-size: 16px; top: 38px; }
    .win-msg { font-size: 22px; }
    .confetti { font-size: 40px; }
    .level-title { font-size: 38px; }
    .level-subtitle { font-size: 18px; }
    #level-display { font-size: 16px; top: 10px; right: 10px; }
  }
</style>
</head>
<body>

<!-- Start Screen -->
<div id="start-screen">
  <div class="big-dino">ü¶ñ</div>
  <h1>Rhaki & Rho's Dino Star Catcher!</h1>
  <p class="subtitle">Help Rhaki & Rho's dinosaur catch all the stars!</p>
  <p class="subtitle" id="instructions-desktop">‚¨ÖÔ∏è ‚û°Ô∏è to move, ‚¨ÜÔ∏è to jump (press twice to double jump!)</p>
  <p class="subtitle" id="instructions-mobile" style="display:none">Tap buttons to move and jump (double tap jump!)</p>
  <button onclick="startGame()">Play!</button>
</div>

<!-- Level Transition Screen -->
<div id="level-screen">
  <div class="big-dino" id="level-emoji">ü¶ñ</div>
  <div class="level-title" id="level-title">Level 2</div>
  <p class="level-subtitle" id="level-subtitle">Things are getting spooky...</p>
  <button onclick="startNextLevel()">Let's Go!</button>
</div>

<!-- Win Screen -->
<div id="win-screen">
  <div class="confetti">üéâüåüüéâ</div>
  <h1>You Win!</h1>
  <p class="win-msg" id="win-msg">Amazing job!</p>
  <div class="big-dino">ü¶ñ‚≠ê</div>
  <button onclick="startGame()">Play Again!</button>
</div>

<!-- Game HUD -->
<div id="score-display"></div>
<div class="stars-left" id="stars-left"></div>
<div id="level-display"></div>

<!-- Game Canvas -->
<canvas id="game"></canvas>

<!-- Mobile on-screen controls -->
<div id="mobile-controls">
  <div id="btn-left" class="ctrl-btn">‚óÄ</div>
  <div id="btn-right" class="ctrl-btn">‚ñ∂</div>
  <div id="btn-jump" class="ctrl-btn">‚ñ≤</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H;
let dino, stars, clouds, particles, platforms, groundY;
let score, totalStars, keysDown, gameRunning;
let animFrame;
let audioCtx, musicGain, sfxGain, musicStarted = false;
let currentLevel = 1;
let fogOffset = 0;
let lightningTimer = 0;
let lightningFlash = 0;
let bats = [];

const DINO_SIZE = 70;
const STAR_SIZE = 40;
const GROUND_HEIGHT = 80;
const PLATFORM_COLOR = '#8D6E63';
const PLATFORM_TOP = '#A1887F';

// Level configurations
const LEVELS = {
  1: {
    totalStars: 10,
    dinoSpeed: 6,
    gravity: 0.55,
    jumpVelocity: -15,
    maxJumps: 2,
    platformCount: () => Math.floor(W / 250),
    platformMinW: 100,
    platformMaxW: 180,
    starBobSpeed: [0.02, 0.04],
    starNearPlatformChance: 0.5,
    name: 'Level 1',
    subtitle: 'A sunny adventure!'
  },
  2: {
    totalStars: 10,
    dinoSpeed: 5.5,
    gravity: 0.6,
    jumpVelocity: -14.5,
    maxJumps: 2,
    platformCount: () => Math.max(3, Math.floor(W / 280)),
    platformMinW: 70,
    platformMaxW: 130,
    starBobSpeed: [0.03, 0.06],
    starNearPlatformChance: 0.35,
    name: 'Level 2',
    subtitle: 'The Spooky Night! üëª'
  }
};

// Mobile detection (must be early since resize() uses it)
const isMobile = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

// ============ AUDIO ENGINE (Web Audio API, no files needed) ============
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.25;
  musicGain.connect(audioCtx.destination);
  sfxGain = audioCtx.createGain();
  sfxGain.gain.value = 0.4;
  sfxGain.connect(audioCtx.destination);
}

function playNote(freq, duration, startTime, gain, type = 'sine') {
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  g.gain.setValueAtTime(0.3, startTime);
  g.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
  osc.connect(g);
  g.connect(gain);
  osc.start(startTime);
  osc.stop(startTime + duration);
}

// Background music ‚Äî changes per level
let musicTimeout;
function playMusic() {
  if (!audioCtx || !gameRunning) return;
  const now = audioCtx.currentTime;

  if (currentLevel === 1) {
    // Happy C major tune, kid-friendly
    const melody = [
      523.25, 587.33, 659.25, 698.46, 783.99, 698.46, 659.25, 587.33,
      523.25, 493.88, 440.00, 493.88, 523.25, 587.33, 659.25, 523.25,
      392.00, 440.00, 493.88, 523.25, 587.33, 523.25, 493.88, 440.00,
      523.25, 659.25, 783.99, 659.25, 523.25, 587.33, 523.25, 493.88
    ];
    const noteDur = 0.22;
    melody.forEach((freq, i) => {
      playNote(freq, noteDur * 0.9, now + i * noteDur, musicGain, 'triangle');
    });
    const bass = [
      261.63, 261.63, 329.63, 329.63, 349.23, 349.23, 261.63, 261.63,
      196.00, 196.00, 220.00, 220.00, 261.63, 261.63, 196.00, 196.00
    ];
    const bassDur = noteDur * 2;
    bass.forEach((freq, i) => {
      playNote(freq, bassDur * 0.8, now + i * bassDur, musicGain, 'sine');
    });
    const loopLen = melody.length * noteDur * 1000;
    musicTimeout = setTimeout(playMusic, loopLen - 50);
  } else {
    // Spooky minor key melody for Level 2
    const melody = [
      329.63, 311.13, 293.66, 277.18, 261.63, 277.18, 293.66, 261.63,
      246.94, 261.63, 293.66, 277.18, 246.94, 233.08, 246.94, 261.63,
      329.63, 349.23, 329.63, 311.13, 293.66, 277.18, 261.63, 246.94,
      220.00, 233.08, 246.94, 261.63, 246.94, 233.08, 220.00, 207.65
    ];
    const noteDur = 0.28;
    melody.forEach((freq, i) => {
      playNote(freq, noteDur * 0.85, now + i * noteDur, musicGain, 'sawtooth');
    });
    // Deep ominous bass
    const bass = [
      130.81, 130.81, 123.47, 123.47, 116.54, 116.54, 110.00, 110.00,
      130.81, 130.81, 116.54, 116.54, 110.00, 110.00, 103.83, 103.83
    ];
    const bassDur = noteDur * 2;
    bass.forEach((freq, i) => {
      playNote(freq, bassDur * 0.9, now + i * bassDur, musicGain, 'sine');
    });
    const loopLen = melody.length * noteDur * 1000;
    musicTimeout = setTimeout(playMusic, loopLen - 50);
  }
}

function stopMusic() {
  clearTimeout(musicTimeout);
  musicStarted = false;
}

function playSfxCollect() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  playNote(880, 0.1, now, sfxGain, 'sine');
  playNote(1108.73, 0.1, now + 0.08, sfxGain, 'sine');
  playNote(1318.51, 0.15, now + 0.16, sfxGain, 'sine');
}

function playSfxJump() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(300, now);
  osc.frequency.exponentialRampToValueAtTime(600, now + 0.15);
  g.gain.setValueAtTime(0.2, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
  osc.connect(g);
  g.connect(sfxGain);
  osc.start(now);
  osc.stop(now + 0.2);
}

function playSfxWin() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => {
    playNote(f, 0.3, now + i * 0.15, sfxGain, 'triangle');
  });
}

function getViewportSize() {
  // visualViewport gives the *actual* visible area on mobile
  // (accounts for URL bar, on-screen keyboard, pinch zoom, etc.)
  if (window.visualViewport) {
    return {
      w: Math.round(window.visualViewport.width),
      h: Math.round(window.visualViewport.height)
    };
  }
  // Fallback for older browsers
  return {
    w: window.innerWidth,
    h: window.innerHeight
  };
}

function resize() {
  const vp = getViewportSize();
  W = canvas.width = vp.w;
  H = canvas.height = vp.h;
  // On mobile, raise the ground so on-screen controls sit below it
  const mobileExtra = isMobile ? 90 : 0;
  groundY = H - GROUND_HEIGHT - mobileExtra;
}

// Listen on visualViewport (fires when URL bar hides/shows, orientation change, etc.)
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', resize);
} else {
  window.addEventListener('resize', resize);
}
// Also handle orientation changes with a small delay (some browsers need it)
window.addEventListener('orientationchange', () => {
  setTimeout(resize, 150);
  setTimeout(resize, 500);
});
resize();
// Delayed resize to catch Dropbox / in-app browser late layout
setTimeout(resize, 300);
setTimeout(resize, 1000);

// --- Drawing helpers ---
// Red Yoshi-inspired character
const YOSHI_RED = '#E53935';
const YOSHI_RED_DARK = '#B71C1C';
const YOSHI_RED_LIGHT = '#EF5350';
const YOSHI_WHITE = '#FFFFFF';
const YOSHI_SHELL = '#E53935';
const YOSHI_BOOT = '#FF8F00';
const YOSHI_BOOT_DARK = '#E65100';

function drawDino(x, y, size, facingRight) {
  ctx.save();
  ctx.translate(x, y);
  if (!facingRight) {
    ctx.scale(-1, 1);
  }

  // === Tail ===
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.moveTo(-size * 0.3, 0);
  ctx.quadraticCurveTo(-size * 0.75, -size * 0.05, -size * 0.7, -size * 0.2);
  ctx.quadraticCurveTo(-size * 0.65, -size * 0.3, -size * 0.55, -size * 0.22);
  ctx.quadraticCurveTo(-size * 0.5, -size * 0.1, -size * 0.25, size * 0.1);
  ctx.fill();

  // === Body ===
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.38, size * 0.42, 0, 0, Math.PI * 2);
  ctx.fill();

  // White belly (Yoshi's iconic white front)
  ctx.fillStyle = YOSHI_WHITE;
  ctx.beginPath();
  ctx.ellipse(size * 0.08, size * 0.05, size * 0.2, size * 0.32, 0.1, 0, Math.PI * 2);
  ctx.fill();

  // === Shell / saddle on back ===
  ctx.fillStyle = YOSHI_RED_DARK;
  ctx.beginPath();
  ctx.ellipse(-size * 0.05, -size * 0.2, size * 0.22, size * 0.12, -0.2, 0, Math.PI * 2);
  ctx.fill();
  // Shell rim (white like Yoshi's shell edge)
  ctx.fillStyle = YOSHI_WHITE;
  ctx.beginPath();
  ctx.ellipse(-size * 0.05, -size * 0.27, size * 0.18, size * 0.05, -0.2, 0, Math.PI * 2);
  ctx.fill();

  // === Head ===
  // Back of head (red)
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.ellipse(size * 0.2, -size * 0.4, size * 0.24, size * 0.24, 0, 0, Math.PI * 2);
  ctx.fill();

  // Big round nose / snout (Yoshi's signature)
  ctx.fillStyle = YOSHI_RED_LIGHT;
  ctx.beginPath();
  ctx.ellipse(size * 0.45, -size * 0.32, size * 0.18, size * 0.15, 0.15, 0, Math.PI * 2);
  ctx.fill();
  // Nostril dot
  ctx.fillStyle = YOSHI_RED_DARK;
  ctx.beginPath();
  ctx.arc(size * 0.55, -size * 0.33, size * 0.03, 0, Math.PI * 2);
  ctx.fill();

  // Cheek patch (rosy)
  ctx.fillStyle = 'rgba(255, 138, 128, 0.4)';
  ctx.beginPath();
  ctx.ellipse(size * 0.32, -size * 0.24, size * 0.08, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eye (big, white, with pupil ‚Äî Yoshi style)
  ctx.fillStyle = YOSHI_WHITE;
  ctx.beginPath();
  ctx.ellipse(size * 0.3, -size * 0.48, size * 0.1, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();
  // Eye outline
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(size * 0.3, -size * 0.48, size * 0.1, size * 0.12, 0, 0, Math.PI * 2);
  ctx.stroke();
  // Pupil
  ctx.fillStyle = '#1B5E20';
  ctx.beginPath();
  ctx.ellipse(size * 0.33, -size * 0.47, size * 0.055, size * 0.07, 0, 0, Math.PI * 2);
  ctx.fill();
  // Eye highlight
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(size * 0.35, -size * 0.5, size * 0.025, 0, Math.PI * 2);
  ctx.fill();

  // Head crest / spike (like Yoshi's head fin)
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.moveTo(size * 0.05, -size * 0.55);
  ctx.quadraticCurveTo(size * 0.0, -size * 0.75, size * 0.15, -size * 0.7);
  ctx.quadraticCurveTo(size * 0.2, -size * 0.62, size * 0.15, -size * 0.5);
  ctx.fill();

  // Smile
  ctx.strokeStyle = YOSHI_RED_DARK;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(size * 0.42, -size * 0.24, size * 0.08, 0.1, Math.PI * 0.7);
  ctx.stroke();

  // === Arms (small, reaching forward, Yoshi style) ===
  ctx.fillStyle = YOSHI_RED;
  ctx.save();
  ctx.translate(size * 0.22, -size * 0.05);
  ctx.rotate(0.4 + Math.sin(Date.now() / 200) * 0.25);
  // Arm
  ctx.beginPath();
  ctx.ellipse(size * 0.1, 0, size * 0.12, size * 0.05, 0.3, 0, Math.PI * 2);
  ctx.fill();
  // White glove / hand
  ctx.fillStyle = YOSHI_WHITE;
  ctx.beginPath();
  ctx.arc(size * 0.2, size * 0.02, size * 0.045, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // === Legs ===
  // Left leg
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.ellipse(-size * 0.12, size * 0.35, size * 0.08, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();
  // Right leg
  ctx.beginPath();
  ctx.ellipse(size * 0.12, size * 0.35, size * 0.08, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();

  // === Boots (orange like Yoshi's) ===
  // Left boot
  ctx.fillStyle = YOSHI_BOOT;
  ctx.beginPath();
  ctx.ellipse(-size * 0.14, size * 0.48, size * 0.12, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();
  // Boot sole
  ctx.fillStyle = YOSHI_BOOT_DARK;
  ctx.beginPath();
  ctx.ellipse(-size * 0.14, size * 0.52, size * 0.12, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();

  // Right boot
  ctx.fillStyle = YOSHI_BOOT;
  ctx.beginPath();
  ctx.ellipse(size * 0.14, size * 0.48, size * 0.12, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();
  // Boot sole
  ctx.fillStyle = YOSHI_BOOT_DARK;
  ctx.beginPath();
  ctx.ellipse(size * 0.14, size * 0.52, size * 0.12, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawStar(x, y, size, twinkle) {
  const glow = 0.7 + Math.sin(twinkle) * 0.3;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(twinkle * 0.3);
  ctx.globalAlpha = glow;

  // Glow
  ctx.fillStyle = '#FFF9C4';
  ctx.beginPath();
  starPath(ctx, 0, 0, size * 0.8, size * 0.4, 5);
  ctx.fill();

  // Star
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  starPath(ctx, 0, 0, size * 0.55, size * 0.25, 5);
  ctx.fill();

  // Sparkle center
  ctx.fillStyle = '#FFF8E1';
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function starPath(ctx, cx, cy, outerR, innerR, points) {
  let rot = -Math.PI / 2;
  let step = Math.PI / points;
  ctx.moveTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
  for (let i = 0; i < points; i++) {
    ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
    rot += step;
    ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
    rot += step;
  }
  ctx.closePath();
}

function drawCloud(x, y, size) {
  if (currentLevel === 1) {
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
  } else {
    ctx.fillStyle = 'rgba(60,60,80,0.6)';
  }
  ctx.beginPath();
  ctx.arc(x, y, size, 0, Math.PI * 2);
  ctx.arc(x + size * 0.8, y - size * 0.3, size * 0.7, 0, Math.PI * 2);
  ctx.arc(x + size * 1.5, y, size * 0.8, 0, Math.PI * 2);
  ctx.arc(x + size * 0.6, y + size * 0.2, size * 0.6, 0, Math.PI * 2);
  ctx.fill();
}

function drawGround() {
  const fullGroundH = H - groundY;
  if (currentLevel === 1) {
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(0, groundY, W, fullGroundH);
    ctx.fillStyle = '#66BB6A';
    ctx.fillRect(0, groundY, W, 8);
    ctx.fillStyle = '#795548';
    ctx.fillRect(0, groundY + 30, W, fullGroundH - 30);
    ctx.fillStyle = '#388E3C';
    for (let i = 0; i < W; i += 40) {
      ctx.beginPath();
      ctx.moveTo(i, groundY);
      ctx.lineTo(i + 5, groundY - 12);
      ctx.lineTo(i + 10, groundY);
      ctx.fill();
    }
  } else {
    // Spooky ground ‚Äî dark earth with dead grass
    ctx.fillStyle = '#2E2E1E';
    ctx.fillRect(0, groundY, W, fullGroundH);
    ctx.fillStyle = '#3A3A28';
    ctx.fillRect(0, groundY, W, 8);
    ctx.fillStyle = '#1A1A10';
    ctx.fillRect(0, groundY + 30, W, fullGroundH - 30);
    // Dead/sparse grass tufts
    ctx.fillStyle = '#4A4A30';
    for (let i = 0; i < W; i += 60) {
      ctx.beginPath();
      ctx.moveTo(i, groundY);
      ctx.lineTo(i + 3, groundY - 8);
      ctx.lineTo(i + 6, groundY);
      ctx.fill();
    }
  }
}

// Dead tree for Level 2
function drawDeadTree(x, baseY, height) {
  // Trunk
  ctx.fillStyle = '#2D1B0E';
  ctx.beginPath();
  ctx.moveTo(x - 8, baseY);
  ctx.lineTo(x - 5, baseY - height);
  ctx.lineTo(x + 5, baseY - height);
  ctx.lineTo(x + 8, baseY);
  ctx.fill();

  // Branches
  ctx.strokeStyle = '#2D1B0E';
  ctx.lineWidth = 4;
  // Left branch
  ctx.beginPath();
  ctx.moveTo(x, baseY - height * 0.6);
  ctx.quadraticCurveTo(x - 30, baseY - height * 0.8, x - 45, baseY - height * 0.65);
  ctx.stroke();
  // Right branch
  ctx.beginPath();
  ctx.moveTo(x, baseY - height * 0.75);
  ctx.quadraticCurveTo(x + 25, baseY - height * 0.95, x + 40, baseY - height * 0.8);
  ctx.stroke();
  // Small twig
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x, baseY - height * 0.9);
  ctx.lineTo(x - 15, baseY - height * 1.05);
  ctx.stroke();
}

// Bat for Level 2
function drawBat(x, y, wingPhase) {
  ctx.fillStyle = '#1A1A2E';
  ctx.save();
  ctx.translate(x, y);
  // Body
  ctx.beginPath();
  ctx.ellipse(0, 0, 6, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  // Wings
  const wingY = Math.sin(wingPhase) * 6;
  ctx.beginPath();
  ctx.moveTo(-4, 0);
  ctx.quadraticCurveTo(-14, -8 + wingY, -18, -2 + wingY);
  ctx.quadraticCurveTo(-12, 2, -4, 0);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(4, 0);
  ctx.quadraticCurveTo(14, -8 + wingY, 18, -2 + wingY);
  ctx.quadraticCurveTo(12, 2, 4, 0);
  ctx.fill();
  // Eyes
  ctx.fillStyle = '#FF5252';
  ctx.beginPath();
  ctx.arc(-2, -1, 1.2, 0, Math.PI * 2);
  ctx.arc(2, -1, 1.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawBackground() {
  if (currentLevel === 1) {
    // ---- LEVEL 1: Sunny day ----
    const grad = ctx.createLinearGradient(0, 0, 0, groundY);
    grad.addColorStop(0, '#87CEEB');
    grad.addColorStop(1, '#B3E5FC');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, groundY);

    // Sun
    ctx.fillStyle = '#FFF176';
    ctx.beginPath();
    ctx.arc(W - 100, 80, 50, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#FFEE58';
    ctx.beginPath();
    ctx.arc(W - 100, 80, 40, 0, Math.PI * 2);
    ctx.fill();

    // Clouds
    clouds.forEach(c => drawCloud(c.x, c.y, c.size));

    // Mountains
    ctx.fillStyle = '#81C784';
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(150, groundY - 120);
    ctx.lineTo(300, groundY);
    ctx.fill();

    ctx.fillStyle = '#66BB6A';
    ctx.beginPath();
    ctx.moveTo(200, groundY);
    ctx.lineTo(400, groundY - 160);
    ctx.lineTo(600, groundY);
    ctx.fill();

    ctx.fillStyle = '#81C784';
    ctx.beginPath();
    ctx.moveTo(W - 400, groundY);
    ctx.lineTo(W - 200, groundY - 100);
    ctx.lineTo(W, groundY);
    ctx.fill();

  } else {
    // ---- LEVEL 2: Spooky night ----
    const grad = ctx.createLinearGradient(0, 0, 0, groundY);
    grad.addColorStop(0, '#0D0D2B');
    grad.addColorStop(0.4, '#1A1A3E');
    grad.addColorStop(1, '#2D1B4E');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, groundY);

    // Lightning flash overlay
    if (lightningFlash > 0) {
      ctx.fillStyle = `rgba(200, 200, 255, ${lightningFlash * 0.3})`;
      ctx.fillRect(0, 0, W, H);
      lightningFlash -= 0.05;
    }

    // Stars in sky (tiny twinkling dots)
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 40; i++) {
      // Use deterministic positions based on index
      const sx = ((i * 137 + 50) % W);
      const sy = ((i * 89 + 20) % (groundY * 0.5));
      const twinkle = 0.3 + Math.sin(Date.now() / 500 + i * 0.7) * 0.7;
      ctx.globalAlpha = twinkle;
      ctx.beginPath();
      ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Eerie moon
    ctx.fillStyle = '#E8E8C8';
    ctx.beginPath();
    ctx.arc(W - 100, 80, 45, 0, Math.PI * 2);
    ctx.fill();
    // Moon glow
    ctx.fillStyle = 'rgba(232, 232, 200, 0.15)';
    ctx.beginPath();
    ctx.arc(W - 100, 80, 70, 0, Math.PI * 2);
    ctx.fill();
    // Moon craters
    ctx.fillStyle = 'rgba(180, 180, 160, 0.4)';
    ctx.beginPath();
    ctx.arc(W - 112, 72, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(W - 90, 90, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(W - 105, 95, 4, 0, Math.PI * 2);
    ctx.fill();

    // Dark clouds
    clouds.forEach(c => drawCloud(c.x, c.y, c.size));

    // Dark mountains / hills
    ctx.fillStyle = '#1A0E2E';
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(150, groundY - 120);
    ctx.lineTo(300, groundY);
    ctx.fill();

    ctx.fillStyle = '#150A28';
    ctx.beginPath();
    ctx.moveTo(200, groundY);
    ctx.lineTo(400, groundY - 160);
    ctx.lineTo(600, groundY);
    ctx.fill();

    ctx.fillStyle = '#1A0E2E';
    ctx.beginPath();
    ctx.moveTo(W - 400, groundY);
    ctx.lineTo(W - 200, groundY - 100);
    ctx.lineTo(W, groundY);
    ctx.fill();

    // Dead trees
    drawDeadTree(80, groundY, 110);
    drawDeadTree(W - 120, groundY, 95);
    drawDeadTree(W * 0.4, groundY, 130);
    drawDeadTree(W * 0.7, groundY, 85);

    // Fog at ground level
    fogOffset += 0.3;
    ctx.fillStyle = 'rgba(100, 80, 120, 0.2)';
    for (let fx = -50 + (fogOffset % 100); fx < W + 50; fx += 100) {
      ctx.beginPath();
      ctx.ellipse(fx, groundY - 10, 80, 18, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.fillStyle = 'rgba(80, 60, 100, 0.15)';
    for (let fx = -30 + ((fogOffset * 0.7) % 120); fx < W + 50; fx += 120) {
      ctx.beginPath();
      ctx.ellipse(fx, groundY - 25, 60, 14, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Bats
    bats.forEach(b => {
      b.x += b.vx;
      b.phase += 0.15;
      if (b.x > W + 30) b.x = -30;
      if (b.x < -30) b.x = W + 30;
      drawBat(b.x, b.y + Math.sin(b.phase * 0.4) * 8, b.phase);
    });

    // Random lightning
    lightningTimer--;
    if (lightningTimer <= 0) {
      lightningTimer = 300 + Math.floor(Math.random() * 400);
      lightningFlash = 1;
    }
  }
}

// --- Particles ---
function spawnParticles(x, y) {
  for (let i = 0; i < 12; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8 - 3,
      life: 1,
      color: ['#FFD700', '#FFF176', '#FFAB00', '#FFE082'][Math.floor(Math.random() * 4)],
      size: Math.random() * 6 + 3
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15;
    p.life -= 0.025;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// --- Platforms ---
function spawnPlatforms() {
  platforms = [];
  const lvl = LEVELS[currentLevel];
  const count = lvl.platformCount();

  // Calculate max reachable height from a single jump
  // height = v^2 / (2 * gravity)  ‚Äî but we leave some margin for error
  const jumpV = Math.abs(lvl.jumpVelocity);
  const singleJumpHeight = (jumpV * jumpV) / (2 * lvl.gravity) * 0.75; // 75% of theoretical max for safety
  // Double jump from a platform can reach roughly this high above it
  const doubleJumpHeight = singleJumpHeight * 1.6;

  // Build a "staircase" of platforms ‚Äî each one is reachable from ground or a lower platform
  // Start from ground level and work upward
  let currentY = groundY; // start from ground
  const usedXRanges = []; // track x positions to spread platforms across screen

  for (let i = 0; i < count; i++) {
    const platW = lvl.platformMinW + Math.random() * (lvl.platformMaxW - lvl.platformMinW);

    // Height step: reachable from currentY via single or double jump
    // First platform is reachable by single jump from ground
    // Higher platforms may need double jump but must be reachable from a previous platform
    const minStep = singleJumpHeight * 0.4; // don't place too close together
    const maxStep = (i === 0) ? singleJumpHeight : doubleJumpHeight;
    const step = minStep + Math.random() * (maxStep - minStep);

    let platY = currentY - step;
    // Clamp so platforms don't go above the top of the screen
    platY = Math.max(80, platY);

    // Spread x across the screen ‚Äî avoid stacking on the same side
    let platX;
    let attempts = 0;
    do {
      platX = 60 + Math.random() * (W - 120 - platW);
      attempts++;
    } while (attempts < 20 && usedXRanges.some(r =>
      Math.abs((platX + platW / 2) - r) < W * 0.2
    ));

    usedXRanges.push(platX + platW / 2);

    platforms.push({
      x: platX,
      y: platY,
      w: platW,
      h: 18
    });

    // Next platform is reachable from this one
    currentY = platY;
  }
}

function drawPlatforms() {
  platforms.forEach(p => {
    if (currentLevel === 1) {
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.fillRect(p.x + 4, p.y + 4, p.w, p.h);
      ctx.fillStyle = PLATFORM_COLOR;
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.fillStyle = PLATFORM_TOP;
      ctx.fillRect(p.x, p.y, p.w, 5);
      ctx.fillStyle = '#66BB6A';
      ctx.fillRect(p.x, p.y - 3, p.w, 5);
      ctx.fillStyle = '#388E3C';
      for (let gx = p.x + 8; gx < p.x + p.w - 8; gx += 18) {
        ctx.beginPath();
        ctx.moveTo(gx, p.y - 3);
        ctx.lineTo(gx + 3, p.y - 11);
        ctx.lineTo(gx + 6, p.y - 3);
        ctx.fill();
      }
    } else {
      // Spooky dark stone platforms
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(p.x + 4, p.y + 4, p.w, p.h);
      ctx.fillStyle = '#3E2723';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.fillStyle = '#4E342E';
      ctx.fillRect(p.x, p.y, p.w, 4);
      // Cracks
      ctx.strokeStyle = '#2A1A14';
      ctx.lineWidth = 1;
      for (let cx = p.x + 15; cx < p.x + p.w - 10; cx += 30) {
        ctx.beginPath();
        ctx.moveTo(cx, p.y + 2);
        ctx.lineTo(cx + 5, p.y + p.h - 2);
        ctx.stroke();
      }
      // Moss
      ctx.fillStyle = 'rgba(50, 80, 40, 0.4)';
      ctx.fillRect(p.x, p.y - 2, p.w, 3);
    }
  });
}

// --- Stars ---
function spawnStar() {
  const lvl = LEVELS[currentLevel];
  const bobSpeedMin = lvl.starBobSpeed[0];
  const bobSpeedRange = lvl.starBobSpeed[1] - lvl.starBobSpeed[0];

  // Calculate max reachable height from ground via double jump
  const jumpV = Math.abs(lvl.jumpVelocity);
  const maxReachFromGround = (jumpV * jumpV) / (2 * lvl.gravity) * 1.5; // double jump ~1.5x

  if (platforms.length > 0 && Math.random() < lvl.starNearPlatformChance) {
    const p = platforms[Math.floor(Math.random() * platforms.length)];
    // Place star reachable by jumping from this platform (single jump height above it)
    const singleJumpH = (jumpV * jumpV) / (2 * lvl.gravity) * 0.65;
    stars.push({
      x: p.x + Math.random() * p.w,
      y: p.y - 30 - Math.random() * Math.min(50, singleJumpH * 0.5),
      phase: Math.random() * Math.PI * 2,
      bobSpeed: bobSpeedMin + Math.random() * bobSpeedRange,
      bobAmount: 10 + Math.random() * 8
    });
  } else {
    // Place star reachable from ground via double jump
    const maxHeight = Math.min(maxReachFromGround, groundY - 80);
    stars.push({
      x: Math.random() * (W - 100) + 50,
      y: groundY - 60 - Math.random() * maxHeight * 0.7,
      phase: Math.random() * Math.PI * 2,
      bobSpeed: bobSpeedMin + Math.random() * bobSpeedRange,
      bobAmount: 12 + Math.random() * 10
    });
  }
}

// --- Game Logic ---
function initGame() {
  const lvl = LEVELS[currentLevel];

  dino = {
    x: W / 2,
    y: groundY - DINO_SIZE * 0.5,
    vx: 0,
    vy: 0,
    onGround: true,
    facingRight: true,
    speed: lvl.dinoSpeed,
    jumpsLeft: lvl.maxJumps,
    maxJumps: lvl.maxJumps
  };

  stars = [];
  clouds = [];
  particles = [];
  platforms = [];
  bats = [];
  score = 0;
  totalStars = lvl.totalStars;
  keysDown = {};
  fogOffset = 0;
  lightningTimer = 300;
  lightningFlash = 0;

  spawnPlatforms();

  // Update page background to match level
  document.body.style.background = currentLevel === 1 ? '#87CEEB' : '#0D0D2B';

  // Spawn initial stars (3 at a time)
  for (let i = 0; i < 3; i++) spawnStar();

  // Clouds
  const cloudCount = currentLevel === 1 ? 5 : 7;
  for (let i = 0; i < cloudCount; i++) {
    clouds.push({
      x: Math.random() * W,
      y: 30 + Math.random() * 100,
      size: 20 + Math.random() * 30,
      speed: currentLevel === 1 ? (0.2 + Math.random() * 0.5) : (0.3 + Math.random() * 0.8)
    });
  }

  // Bats for Level 2
  if (currentLevel === 2) {
    for (let i = 0; i < 4; i++) {
      bats.push({
        x: Math.random() * W,
        y: 40 + Math.random() * 80,
        vx: (Math.random() < 0.5 ? 1 : -1) * (1 + Math.random() * 1.5),
        phase: Math.random() * Math.PI * 2
      });
    }
  }
}

function startGame() {
  currentLevel = 1;
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('win-screen').style.display = 'none';
  document.getElementById('level-screen').style.display = 'none';
  document.getElementById('score-display').style.display = 'block';
  document.getElementById('stars-left').style.display = 'block';
  document.getElementById('level-display').style.display = 'block';

  resize();
  initGame();
  gameRunning = true;

  // Start audio (needs user gesture)
  initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  stopMusic();
  musicStarted = true;
  playMusic();

  if (animFrame) cancelAnimationFrame(animFrame);
  loop();
}

function winGame() {
  gameRunning = false;
  stopMusic();
  playSfxWin();
  document.getElementById('score-display').style.display = 'none';
  document.getElementById('stars-left').style.display = 'none';
  document.getElementById('level-display').style.display = 'none';

  if (currentLevel === 1) {
    // Show Level 2 transition screen
    const levelScreen = document.getElementById('level-screen');
    levelScreen.style.background = 'linear-gradient(180deg, #0D0D2B 0%, #2D1B4E 50%, #1A0E2E 100%)';
    document.getElementById('level-emoji').textContent = 'ü¶ñüëª';
    document.getElementById('level-title').textContent = 'Level 2: Spooky Night!';
    document.getElementById('level-subtitle').textContent = 'It\'s getting dark and mysterious... Can you find all the stars?';
    levelScreen.style.display = 'flex';
  } else {
    // Final win ‚Äî beat both levels!
    const msgs = [
      "Rhaki & Rho, you're super star catchers! ‚≠êüèÜ",
      "Rhaki & Rho conquered the spooky night! ü¶ñüåü",
      "Amazing job, Rhaki & Rho! Both levels beaten! üéä",
      "Rhaki & Rho are champions! Hooray! üèÜüéâ"
    ];
    document.getElementById('win-msg').textContent = msgs[Math.floor(Math.random() * msgs.length)];
    document.getElementById('win-screen').style.display = 'flex';
  }
}

function startNextLevel() {
  document.getElementById('level-screen').style.display = 'none';
  currentLevel = 2;
  document.getElementById('score-display').style.display = 'block';
  document.getElementById('stars-left').style.display = 'block';
  document.getElementById('level-display').style.display = 'block';

  resize();
  initGame();
  gameRunning = true;

  if (audioCtx.state === 'suspended') audioCtx.resume();
  stopMusic();
  musicStarted = true;
  playMusic();

  if (animFrame) cancelAnimationFrame(animFrame);
  loop();
}

function update() {
  // Movement
  let moving = false;
  if (keysDown['ArrowLeft'] || keysDown['left']) {
    dino.vx = -dino.speed;
    dino.facingRight = false;
    moving = true;
  }
  if (keysDown['ArrowRight'] || keysDown['right']) {
    dino.vx = dino.speed;
    dino.facingRight = true;
    moving = true;
  }
  if (!moving) {
    dino.vx *= 0.8;
  }

  // Jump (double jump supported!)
  if (keysDown['ArrowUp'] || keysDown[' '] || keysDown['up']) {
    if (!dino._jumpHeld && dino.jumpsLeft > 0) {
      dino.vy = LEVELS[currentLevel].jumpVelocity;
      dino.onGround = false;
      dino.jumpsLeft--;
      dino._jumpHeld = true;
      playSfxJump();
    }
  } else {
    dino._jumpHeld = false;
  }

  // Gravity
  dino.vy += LEVELS[currentLevel].gravity;
  dino.x += dino.vx;
  dino.y += dino.vy;

  // Platform collision (only when falling)
  if (dino.vy > 0) {
    for (const p of platforms) {
      const dinoBottom = dino.y + DINO_SIZE * 0.5;
      const dinoLeft = dino.x - DINO_SIZE * 0.3;
      const dinoRight = dino.x + DINO_SIZE * 0.3;
      if (dinoBottom >= p.y && dinoBottom <= p.y + p.h + 10 &&
          dinoRight > p.x && dinoLeft < p.x + p.w) {
        dino.y = p.y - DINO_SIZE * 0.5;
        dino.vy = 0;
        dino.onGround = true;
        dino.jumpsLeft = dino.maxJumps;
        break;
      }
    }
  }

  // Ground collision
  if (dino.y >= groundY - DINO_SIZE * 0.5) {
    dino.y = groundY - DINO_SIZE * 0.5;
    dino.vy = 0;
    dino.onGround = true;
    dino.jumpsLeft = dino.maxJumps;
  }

  // Screen wrapping
  if (dino.x < -DINO_SIZE) dino.x = W + DINO_SIZE;
  if (dino.x > W + DINO_SIZE) dino.x = -DINO_SIZE;

  // Star collection
  for (let i = stars.length - 1; i >= 0; i--) {
    const s = stars[i];
    const sy = s.y + Math.sin(s.phase) * s.bobAmount;
    const dx = dino.x - s.x;
    const dy = dino.y - sy;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < DINO_SIZE * 0.5 + STAR_SIZE * 0.5) {
      // Collected!
      spawnParticles(s.x, sy);
      playSfxCollect();
      stars.splice(i, 1);
      score++;

      if (score >= totalStars) {
        winGame();
        return;
      }

      // Spawn a new star
      spawnStar();
    }
  }

  // Animate star bobbing
  stars.forEach(s => {
    s.phase += s.bobSpeed;
  });

  // Move clouds
  clouds.forEach(c => {
    c.x += c.speed;
    if (c.x > W + 100) c.x = -100;
  });

  updateParticles();
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  drawBackground();
  drawGround();
  drawPlatforms();

  // Stars
  stars.forEach(s => {
    const sy = s.y + Math.sin(s.phase) * s.bobAmount;
    drawStar(s.x, sy, STAR_SIZE, s.phase);
  });

  // Dino
  drawDino(dino.x, dino.y, DINO_SIZE, dino.facingRight);

  // Particles
  drawParticles();

  // HUD
  document.getElementById('score-display').textContent = `‚≠ê ${score} / ${totalStars}`;
  document.getElementById('stars-left').textContent =
    `Catch ${totalStars - score} more star${totalStars - score !== 1 ? 's' : ''}!`;
  document.getElementById('level-display').textContent = LEVELS[currentLevel].name;
}

function loop() {
  if (!gameRunning) return;
  update();
  draw();
  animFrame = requestAnimationFrame(loop);
}

// --- Input ---
window.addEventListener('keydown', e => {
  keysDown[e.key] = true;
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
    e.preventDefault();
  }
});

window.addEventListener('keyup', e => {
  keysDown[e.key] = false;
});

// ===== Mobile on-screen controls =====
function showMobileUI() {
  document.getElementById('mobile-controls').style.display = 'block';
  document.getElementById('instructions-desktop').style.display = 'none';
  document.getElementById('instructions-mobile').style.display = 'block';
}

if (isMobile) showMobileUI();

// Prevent all unwanted mobile browser behaviors
document.addEventListener('touchmove', e => {
  if (gameRunning) e.preventDefault();
}, { passive: false });

// Prevent double-tap zoom on iOS
let lastTouchEnd = 0;
document.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, { passive: false });

// ---- On-screen button handlers ----
function setupButton(id, keyName) {
  const btn = document.getElementById(id);

  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    e.stopPropagation();
    keysDown[keyName] = true;
    btn.classList.add('pressed');
  }, { passive: false });

  btn.addEventListener('touchend', e => {
    e.preventDefault();
    e.stopPropagation();
    keysDown[keyName] = false;
    btn.classList.remove('pressed');
  }, { passive: false });

  btn.addEventListener('touchcancel', e => {
    keysDown[keyName] = false;
    btn.classList.remove('pressed');
  });

  // Also clear if finger slides off button
  btn.addEventListener('touchleave', e => {
    keysDown[keyName] = false;
    btn.classList.remove('pressed');
  });
}

setupButton('btn-left', 'left');
setupButton('btn-right', 'right');
setupButton('btn-jump', 'up');

// Multi-touch: allow holding left/right AND tapping jump simultaneously
// We handle this by listening on the document for touches and mapping
// each active touch to the button it's over.
document.addEventListener('touchstart', e => {
  if (!gameRunning) return;
  // Prevent pull-to-refresh and overscroll
  if (e.target === canvas) e.preventDefault();
}, { passive: false });

// Fallback: if user touches directly on the canvas (not a button),
// use left-half/right-half for movement + tap to also jump
canvas.addEventListener('touchstart', e => {
  if (!gameRunning) return;
  e.preventDefault();
  for (const touch of e.changedTouches) {
    // If touch is in the lower control zone, ignore (buttons handle it)
    if (touch.clientY > H - 170) return;
    // Tap anywhere on canvas = jump
    keysDown['up'] = true;
    setTimeout(() => { keysDown['up'] = false; }, 100);
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
}, { passive: false });
</script>
</body>
</html>
