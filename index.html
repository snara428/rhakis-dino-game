<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Rhaki & Rho's Dino">
<title>Rhaki & Rho's Dino Star Catcher!</title>
<!-- Favicon and Apple touch icon: Red Yoshi PNG -->
<link rel="icon" type="image/png" href="apple-touch-icon.png">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    width: 100%;
    height: 100%;
    height: 100dvh;          /* dynamic viewport height ‚Äî shrinks with URL bar */
    overflow: hidden;
    background: #87CEEB;
    font-family: 'Comic Sans MS', 'Chalkboard SE', cursive;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;       /* prevent all browser touch gestures globally */
    overscroll-behavior: none; /* prevent pull-to-refresh / overscroll bounce */
    position: fixed;          /* prevents iOS Safari rubber-banding */
    inset: 0;
  }

  canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
  }

  #start-screen, #win-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
    z-index: 10;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  #win-screen { display: none; }

  h1 {
    font-size: 52px;
    color: #2E7D32;
    text-shadow: 3px 3px 0 #fff;
    margin-bottom: 10px;
    text-align: center;
    padding: 0 20px;
  }

  .subtitle {
    font-size: 24px;
    color: #555;
    margin-bottom: 30px;
    text-align: center;
    padding: 0 20px;
  }

  .big-dino {
    font-size: 120px;
    margin-bottom: 20px;
  }

  button {
    font-family: 'Comic Sans MS', 'Chalkboard SE', cursive;
    font-size: 32px;
    padding: 15px 50px;
    border: 4px solid #2E7D32;
    border-radius: 20px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
    box-shadow: 0 6px 0 #2E7D32;
    transition: transform 0.1s;
  }

  button:hover {
    transform: translateY(2px);
    box-shadow: 0 4px 0 #2E7D32;
  }

  button:active {
    transform: translateY(4px);
    box-shadow: 0 2px 0 #2E7D32;
  }

  #score-display {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    color: #fff;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    z-index: 5;
  }

  .stars-left {
    position: absolute;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 20px;
    color: #FFD700;
    text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
    z-index: 5;
  }

  #win-screen h1 { color: #FF6F00; }

  .win-msg {
    font-size: 28px;
    color: #333;
    margin-bottom: 20px;
  }

  .confetti {
    font-size: 60px;
    margin-bottom: 20px;
  }

  /* ===== Mobile on-screen controls ===== */
  #mobile-controls {
    display: none;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 160px;
    z-index: 8;
    pointer-events: none;
    padding: 0 15px 15px;
  }

  .ctrl-btn {
    position: absolute;
    pointer-events: auto;
    border: 3px solid rgba(255,255,255,0.5);
    border-radius: 50%;
    background: rgba(255,255,255,0.25);
    color: rgba(255,255,255,0.85);
    font-size: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
  }

  .ctrl-btn:active, .ctrl-btn.pressed {
    background: rgba(255,255,255,0.5);
    border-color: rgba(255,255,255,0.8);
  }

  #btn-left {
    width: 72px; height: 72px;
    left: calc(20px + env(safe-area-inset-left));
    bottom: calc(25px + env(safe-area-inset-bottom));
  }
  #btn-right {
    width: 72px; height: 72px;
    left: calc(110px + env(safe-area-inset-left));
    bottom: calc(25px + env(safe-area-inset-bottom));
  }
  #btn-jump {
    width: 90px; height: 90px;
    right: calc(20px + env(safe-area-inset-right));
    bottom: calc(20px + env(safe-area-inset-bottom));
    font-size: 32px;
    border-radius: 50%;
    background: rgba(76, 175, 80, 0.4);
    border-color: rgba(76, 175, 80, 0.7);
  }
  #btn-jump:active, #btn-jump.pressed {
    background: rgba(76, 175, 80, 0.65);
    border-color: rgba(76, 175, 80, 0.9);
  }

  /* Responsive text for small screens */
  @media (max-width: 600px) {
    h1 { font-size: 32px; }
    .subtitle { font-size: 16px; margin-bottom: 15px; }
    .big-dino { font-size: 80px; margin-bottom: 10px; }
    button { font-size: 24px; padding: 12px 36px; }
    #score-display { font-size: 22px; top: 10px; }
    .stars-left { font-size: 16px; top: 38px; }
    .win-msg { font-size: 22px; }
    .confetti { font-size: 40px; }
  }
</style>
</head>
<body>

<!-- Start Screen -->
<div id="start-screen">
  <div class="big-dino">ü¶ñ</div>
  <h1>Rhaki & Rho's Dino Star Catcher!</h1>
  <p class="subtitle">Help Rhaki & Rho's dinosaur catch all the stars!</p>
  <p class="subtitle" id="instructions-desktop">‚¨ÖÔ∏è ‚û°Ô∏è to move, ‚¨ÜÔ∏è to jump (press twice to double jump!)</p>
  <p class="subtitle" id="instructions-mobile" style="display:none">Tap buttons to move and jump (double tap jump!)</p>
  <button onclick="startGame()">Play!</button>
</div>

<!-- Win Screen -->
<div id="win-screen">
  <div class="confetti">üéâüåüüéâ</div>
  <h1>You Win!</h1>
  <p class="win-msg" id="win-msg">Amazing job!</p>
  <div class="big-dino">ü¶ñ‚≠ê</div>
  <button onclick="startGame()">Play Again!</button>
</div>

<!-- Game HUD -->
<div id="score-display"></div>
<div class="stars-left" id="stars-left"></div>

<!-- Game Canvas -->
<canvas id="game"></canvas>

<!-- Mobile on-screen controls -->
<div id="mobile-controls">
  <div id="btn-left" class="ctrl-btn">‚óÄ</div>
  <div id="btn-right" class="ctrl-btn">‚ñ∂</div>
  <div id="btn-jump" class="ctrl-btn">‚ñ≤</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H;
let dino, stars, clouds, particles, platforms, groundY;
let score, totalStars, keysDown, gameRunning;
let animFrame;
let audioCtx, musicGain, sfxGain, musicStarted = false;

const DINO_SIZE = 70;
const STAR_SIZE = 40;
const GROUND_HEIGHT = 80;
const TOTAL_STARS_TO_WIN = 10;
const PLATFORM_COLOR = '#8D6E63';
const PLATFORM_TOP = '#A1887F';

// Mobile detection (must be early since resize() uses it)
const isMobile = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

// ============ AUDIO ENGINE (Web Audio API, no files needed) ============
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.25;
  musicGain.connect(audioCtx.destination);
  sfxGain = audioCtx.createGain();
  sfxGain.gain.value = 0.4;
  sfxGain.connect(audioCtx.destination);
}

function playNote(freq, duration, startTime, gain, type = 'sine') {
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  g.gain.setValueAtTime(0.3, startTime);
  g.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
  osc.connect(g);
  g.connect(gain);
  osc.start(startTime);
  osc.stop(startTime + duration);
}

// Happy looping background melody
let musicTimeout;
function playMusic() {
  if (!audioCtx || !gameRunning) return;
  const now = audioCtx.currentTime;
  // C major happy tune, kid-friendly
  const melody = [
    523.25, 587.33, 659.25, 698.46, 783.99, 698.46, 659.25, 587.33,
    523.25, 493.88, 440.00, 493.88, 523.25, 587.33, 659.25, 523.25,
    392.00, 440.00, 493.88, 523.25, 587.33, 523.25, 493.88, 440.00,
    523.25, 659.25, 783.99, 659.25, 523.25, 587.33, 523.25, 493.88
  ];
  const noteDur = 0.22;
  melody.forEach((freq, i) => {
    playNote(freq, noteDur * 0.9, now + i * noteDur, musicGain, 'triangle');
  });
  // Also add a simple bass line
  const bass = [
    261.63, 261.63, 329.63, 329.63, 349.23, 349.23, 261.63, 261.63,
    196.00, 196.00, 220.00, 220.00, 261.63, 261.63, 196.00, 196.00
  ];
  const bassDur = noteDur * 2;
  bass.forEach((freq, i) => {
    playNote(freq, bassDur * 0.8, now + i * bassDur, musicGain, 'sine');
  });
  // Loop
  const loopLen = melody.length * noteDur * 1000;
  musicTimeout = setTimeout(playMusic, loopLen - 50);
}

function stopMusic() {
  clearTimeout(musicTimeout);
  musicStarted = false;
}

function playSfxCollect() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  playNote(880, 0.1, now, sfxGain, 'sine');
  playNote(1108.73, 0.1, now + 0.08, sfxGain, 'sine');
  playNote(1318.51, 0.15, now + 0.16, sfxGain, 'sine');
}

function playSfxJump() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(300, now);
  osc.frequency.exponentialRampToValueAtTime(600, now + 0.15);
  g.gain.setValueAtTime(0.2, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
  osc.connect(g);
  g.connect(sfxGain);
  osc.start(now);
  osc.stop(now + 0.2);
}

function playSfxWin() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => {
    playNote(f, 0.3, now + i * 0.15, sfxGain, 'triangle');
  });
}

function getViewportSize() {
  // visualViewport gives the *actual* visible area on mobile
  // (accounts for URL bar, on-screen keyboard, pinch zoom, etc.)
  if (window.visualViewport) {
    return {
      w: Math.round(window.visualViewport.width),
      h: Math.round(window.visualViewport.height)
    };
  }
  // Fallback for older browsers
  return {
    w: window.innerWidth,
    h: window.innerHeight
  };
}

function resize() {
  const vp = getViewportSize();
  W = canvas.width = vp.w;
  H = canvas.height = vp.h;
  // On mobile, raise the ground so on-screen controls sit below it
  const mobileExtra = isMobile ? 90 : 0;
  groundY = H - GROUND_HEIGHT - mobileExtra;
}

// Listen on visualViewport (fires when URL bar hides/shows, orientation change, etc.)
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', resize);
} else {
  window.addEventListener('resize', resize);
}
// Also handle orientation changes with a small delay (some browsers need it)
window.addEventListener('orientationchange', () => {
  setTimeout(resize, 150);
  setTimeout(resize, 500);
});
resize();
// Delayed resize to catch Dropbox / in-app browser late layout
setTimeout(resize, 300);
setTimeout(resize, 1000);

// --- Drawing helpers ---
// Red Yoshi-inspired character
const YOSHI_RED = '#E53935';
const YOSHI_RED_DARK = '#B71C1C';
const YOSHI_RED_LIGHT = '#EF5350';
const YOSHI_WHITE = '#FFFFFF';
const YOSHI_SHELL = '#E53935';
const YOSHI_BOOT = '#FF8F00';
const YOSHI_BOOT_DARK = '#E65100';

function drawDino(x, y, size, facingRight) {
  ctx.save();
  ctx.translate(x, y);
  if (!facingRight) {
    ctx.scale(-1, 1);
  }

  // === Tail ===
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.moveTo(-size * 0.3, 0);
  ctx.quadraticCurveTo(-size * 0.75, -size * 0.05, -size * 0.7, -size * 0.2);
  ctx.quadraticCurveTo(-size * 0.65, -size * 0.3, -size * 0.55, -size * 0.22);
  ctx.quadraticCurveTo(-size * 0.5, -size * 0.1, -size * 0.25, size * 0.1);
  ctx.fill();

  // === Body ===
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.38, size * 0.42, 0, 0, Math.PI * 2);
  ctx.fill();

  // White belly (Yoshi's iconic white front)
  ctx.fillStyle = YOSHI_WHITE;
  ctx.beginPath();
  ctx.ellipse(size * 0.08, size * 0.05, size * 0.2, size * 0.32, 0.1, 0, Math.PI * 2);
  ctx.fill();

  // === Shell / saddle on back ===
  ctx.fillStyle = YOSHI_RED_DARK;
  ctx.beginPath();
  ctx.ellipse(-size * 0.05, -size * 0.2, size * 0.22, size * 0.12, -0.2, 0, Math.PI * 2);
  ctx.fill();
  // Shell rim (white like Yoshi's shell edge)
  ctx.fillStyle = YOSHI_WHITE;
  ctx.beginPath();
  ctx.ellipse(-size * 0.05, -size * 0.27, size * 0.18, size * 0.05, -0.2, 0, Math.PI * 2);
  ctx.fill();

  // === Head ===
  // Back of head (red)
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.ellipse(size * 0.2, -size * 0.4, size * 0.24, size * 0.24, 0, 0, Math.PI * 2);
  ctx.fill();

  // Big round nose / snout (Yoshi's signature)
  ctx.fillStyle = YOSHI_RED_LIGHT;
  ctx.beginPath();
  ctx.ellipse(size * 0.45, -size * 0.32, size * 0.18, size * 0.15, 0.15, 0, Math.PI * 2);
  ctx.fill();
  // Nostril dot
  ctx.fillStyle = YOSHI_RED_DARK;
  ctx.beginPath();
  ctx.arc(size * 0.55, -size * 0.33, size * 0.03, 0, Math.PI * 2);
  ctx.fill();

  // Cheek patch (rosy)
  ctx.fillStyle = 'rgba(255, 138, 128, 0.4)';
  ctx.beginPath();
  ctx.ellipse(size * 0.32, -size * 0.24, size * 0.08, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eye (big, white, with pupil ‚Äî Yoshi style)
  ctx.fillStyle = YOSHI_WHITE;
  ctx.beginPath();
  ctx.ellipse(size * 0.3, -size * 0.48, size * 0.1, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();
  // Eye outline
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(size * 0.3, -size * 0.48, size * 0.1, size * 0.12, 0, 0, Math.PI * 2);
  ctx.stroke();
  // Pupil
  ctx.fillStyle = '#1B5E20';
  ctx.beginPath();
  ctx.ellipse(size * 0.33, -size * 0.47, size * 0.055, size * 0.07, 0, 0, Math.PI * 2);
  ctx.fill();
  // Eye highlight
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(size * 0.35, -size * 0.5, size * 0.025, 0, Math.PI * 2);
  ctx.fill();

  // Head crest / spike (like Yoshi's head fin)
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.moveTo(size * 0.05, -size * 0.55);
  ctx.quadraticCurveTo(size * 0.0, -size * 0.75, size * 0.15, -size * 0.7);
  ctx.quadraticCurveTo(size * 0.2, -size * 0.62, size * 0.15, -size * 0.5);
  ctx.fill();

  // Smile
  ctx.strokeStyle = YOSHI_RED_DARK;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(size * 0.42, -size * 0.24, size * 0.08, 0.1, Math.PI * 0.7);
  ctx.stroke();

  // === Arms (small, reaching forward, Yoshi style) ===
  ctx.fillStyle = YOSHI_RED;
  ctx.save();
  ctx.translate(size * 0.22, -size * 0.05);
  ctx.rotate(0.4 + Math.sin(Date.now() / 200) * 0.25);
  // Arm
  ctx.beginPath();
  ctx.ellipse(size * 0.1, 0, size * 0.12, size * 0.05, 0.3, 0, Math.PI * 2);
  ctx.fill();
  // White glove / hand
  ctx.fillStyle = YOSHI_WHITE;
  ctx.beginPath();
  ctx.arc(size * 0.2, size * 0.02, size * 0.045, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // === Legs ===
  // Left leg
  ctx.fillStyle = YOSHI_RED;
  ctx.beginPath();
  ctx.ellipse(-size * 0.12, size * 0.35, size * 0.08, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();
  // Right leg
  ctx.beginPath();
  ctx.ellipse(size * 0.12, size * 0.35, size * 0.08, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();

  // === Boots (orange like Yoshi's) ===
  // Left boot
  ctx.fillStyle = YOSHI_BOOT;
  ctx.beginPath();
  ctx.ellipse(-size * 0.14, size * 0.48, size * 0.12, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();
  // Boot sole
  ctx.fillStyle = YOSHI_BOOT_DARK;
  ctx.beginPath();
  ctx.ellipse(-size * 0.14, size * 0.52, size * 0.12, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();

  // Right boot
  ctx.fillStyle = YOSHI_BOOT;
  ctx.beginPath();
  ctx.ellipse(size * 0.14, size * 0.48, size * 0.12, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();
  // Boot sole
  ctx.fillStyle = YOSHI_BOOT_DARK;
  ctx.beginPath();
  ctx.ellipse(size * 0.14, size * 0.52, size * 0.12, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawStar(x, y, size, twinkle) {
  const glow = 0.7 + Math.sin(twinkle) * 0.3;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(twinkle * 0.3);
  ctx.globalAlpha = glow;

  // Glow
  ctx.fillStyle = '#FFF9C4';
  ctx.beginPath();
  starPath(ctx, 0, 0, size * 0.8, size * 0.4, 5);
  ctx.fill();

  // Star
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  starPath(ctx, 0, 0, size * 0.55, size * 0.25, 5);
  ctx.fill();

  // Sparkle center
  ctx.fillStyle = '#FFF8E1';
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function starPath(ctx, cx, cy, outerR, innerR, points) {
  let rot = -Math.PI / 2;
  let step = Math.PI / points;
  ctx.moveTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
  for (let i = 0; i < points; i++) {
    ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
    rot += step;
    ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
    rot += step;
  }
  ctx.closePath();
}

function drawCloud(x, y, size) {
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.beginPath();
  ctx.arc(x, y, size, 0, Math.PI * 2);
  ctx.arc(x + size * 0.8, y - size * 0.3, size * 0.7, 0, Math.PI * 2);
  ctx.arc(x + size * 1.5, y, size * 0.8, 0, Math.PI * 2);
  ctx.arc(x + size * 0.6, y + size * 0.2, size * 0.6, 0, Math.PI * 2);
  ctx.fill();
}

function drawGround() {
  const fullGroundH = H - groundY; // fills to bottom of screen
  // Grass
  ctx.fillStyle = '#4CAF50';
  ctx.fillRect(0, groundY, W, fullGroundH);

  // Grass top highlight
  ctx.fillStyle = '#66BB6A';
  ctx.fillRect(0, groundY, W, 8);

  // Dirt
  ctx.fillStyle = '#795548';
  ctx.fillRect(0, groundY + 30, W, fullGroundH - 30);

  // Little grass tufts
  ctx.fillStyle = '#388E3C';
  for (let i = 0; i < W; i += 40) {
    ctx.beginPath();
    ctx.moveTo(i, groundY);
    ctx.lineTo(i + 5, groundY - 12);
    ctx.lineTo(i + 10, groundY);
    ctx.fill();
  }
}

function drawBackground() {
  // Sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, groundY);
  grad.addColorStop(0, '#87CEEB');
  grad.addColorStop(1, '#B3E5FC');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, groundY);

  // Sun
  ctx.fillStyle = '#FFF176';
  ctx.beginPath();
  ctx.arc(W - 100, 80, 50, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFEE58';
  ctx.beginPath();
  ctx.arc(W - 100, 80, 40, 0, Math.PI * 2);
  ctx.fill();

  // Clouds
  clouds.forEach(c => {
    drawCloud(c.x, c.y, c.size);
  });

  // Mountains in background
  ctx.fillStyle = '#81C784';
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  ctx.lineTo(150, groundY - 120);
  ctx.lineTo(300, groundY);
  ctx.fill();

  ctx.fillStyle = '#66BB6A';
  ctx.beginPath();
  ctx.moveTo(200, groundY);
  ctx.lineTo(400, groundY - 160);
  ctx.lineTo(600, groundY);
  ctx.fill();

  ctx.fillStyle = '#81C784';
  ctx.beginPath();
  ctx.moveTo(W - 400, groundY);
  ctx.lineTo(W - 200, groundY - 100);
  ctx.lineTo(W, groundY);
  ctx.fill();
}

// --- Particles ---
function spawnParticles(x, y) {
  for (let i = 0; i < 12; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8 - 3,
      life: 1,
      color: ['#FFD700', '#FFF176', '#FFAB00', '#FFE082'][Math.floor(Math.random() * 4)],
      size: Math.random() * 6 + 3
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15;
    p.life -= 0.025;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// --- Platforms ---
function spawnPlatforms() {
  platforms = [];
  const count = Math.floor(W / 250);
  for (let i = 0; i < count; i++) {
    platforms.push({
      x: 100 + Math.random() * (W - 200),
      y: groundY - 150 - Math.random() * (groundY - 300),
      w: 100 + Math.random() * 80,
      h: 18
    });
  }
}

function drawPlatforms() {
  platforms.forEach(p => {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(p.x + 4, p.y + 4, p.w, p.h);
    // Main platform
    ctx.fillStyle = PLATFORM_COLOR;
    ctx.fillRect(p.x, p.y, p.w, p.h);
    // Top highlight
    ctx.fillStyle = PLATFORM_TOP;
    ctx.fillRect(p.x, p.y, p.w, 5);
    // Grass on top
    ctx.fillStyle = '#66BB6A';
    ctx.fillRect(p.x, p.y - 3, p.w, 5);
    // Little grass tufts on platform
    ctx.fillStyle = '#388E3C';
    for (let gx = p.x + 8; gx < p.x + p.w - 8; gx += 18) {
      ctx.beginPath();
      ctx.moveTo(gx, p.y - 3);
      ctx.lineTo(gx + 3, p.y - 11);
      ctx.lineTo(gx + 6, p.y - 3);
      ctx.fill();
    }
  });
}

// --- Stars ---
function spawnStar() {
  // 50% of stars spawn near platforms so they're reachable
  if (platforms.length > 0 && Math.random() < 0.5) {
    const p = platforms[Math.floor(Math.random() * platforms.length)];
    stars.push({
      x: p.x + Math.random() * p.w,
      y: p.y - 40 - Math.random() * 60,
      phase: Math.random() * Math.PI * 2,
      bobSpeed: 0.02 + Math.random() * 0.02,
      bobAmount: 10 + Math.random() * 8
    });
  } else {
    // Spawn in lower/mid area reachable by double jump
    stars.push({
      x: Math.random() * (W - 100) + 50,
      y: groundY - 80 - Math.random() * (groundY * 0.45),
      phase: Math.random() * Math.PI * 2,
      bobSpeed: 0.02 + Math.random() * 0.02,
      bobAmount: 12 + Math.random() * 10
    });
  }
}

// --- Game Logic ---
function initGame() {
  dino = {
    x: W / 2,
    y: groundY - DINO_SIZE * 0.5,
    vx: 0,
    vy: 0,
    onGround: true,
    facingRight: true,
    speed: 6,
    jumpsLeft: 2,   // double jump!
    maxJumps: 2
  };

  stars = [];
  clouds = [];
  particles = [];
  platforms = [];
  score = 0;
  totalStars = TOTAL_STARS_TO_WIN;
  keysDown = {};

  spawnPlatforms();

  // Spawn initial stars (3 at a time)
  for (let i = 0; i < 3; i++) spawnStar();

  // Clouds
  for (let i = 0; i < 5; i++) {
    clouds.push({
      x: Math.random() * W,
      y: 30 + Math.random() * 100,
      size: 20 + Math.random() * 30,
      speed: 0.2 + Math.random() * 0.5
    });
  }
}

function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('win-screen').style.display = 'none';
  document.getElementById('score-display').style.display = 'block';
  document.getElementById('stars-left').style.display = 'block';

  resize();
  initGame();
  gameRunning = true;

  // Start audio (needs user gesture)
  initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  stopMusic();
  musicStarted = true;
  playMusic();

  if (animFrame) cancelAnimationFrame(animFrame);
  loop();
}

function winGame() {
  gameRunning = false;
  stopMusic();
  playSfxWin();
  document.getElementById('score-display').style.display = 'none';
  document.getElementById('stars-left').style.display = 'none';

  const msgs = [
    "Rhaki & Rho, you're star catchers! ‚≠ê",
    "Rhaki & Rho's Yoshi is so happy! ü¶ñ",
    "Amazing job, Rhaki & Rho! üåü",
    "Rhaki & Rho did it! Hooray! üéä"
  ];
  document.getElementById('win-msg').textContent = msgs[Math.floor(Math.random() * msgs.length)];
  document.getElementById('win-screen').style.display = 'flex';
}

function update() {
  // Movement
  let moving = false;
  if (keysDown['ArrowLeft'] || keysDown['left']) {
    dino.vx = -dino.speed;
    dino.facingRight = false;
    moving = true;
  }
  if (keysDown['ArrowRight'] || keysDown['right']) {
    dino.vx = dino.speed;
    dino.facingRight = true;
    moving = true;
  }
  if (!moving) {
    dino.vx *= 0.8;
  }

  // Jump (double jump supported!)
  if (keysDown['ArrowUp'] || keysDown[' '] || keysDown['up']) {
    if (!dino._jumpHeld && dino.jumpsLeft > 0) {
      dino.vy = -15;
      dino.onGround = false;
      dino.jumpsLeft--;
      dino._jumpHeld = true;
      playSfxJump();
    }
  } else {
    dino._jumpHeld = false;
  }

  // Gravity
  dino.vy += 0.55;
  dino.x += dino.vx;
  dino.y += dino.vy;

  // Platform collision (only when falling)
  if (dino.vy > 0) {
    for (const p of platforms) {
      const dinoBottom = dino.y + DINO_SIZE * 0.5;
      const dinoLeft = dino.x - DINO_SIZE * 0.3;
      const dinoRight = dino.x + DINO_SIZE * 0.3;
      if (dinoBottom >= p.y && dinoBottom <= p.y + p.h + 10 &&
          dinoRight > p.x && dinoLeft < p.x + p.w) {
        dino.y = p.y - DINO_SIZE * 0.5;
        dino.vy = 0;
        dino.onGround = true;
        dino.jumpsLeft = dino.maxJumps;
        break;
      }
    }
  }

  // Ground collision
  if (dino.y >= groundY - DINO_SIZE * 0.5) {
    dino.y = groundY - DINO_SIZE * 0.5;
    dino.vy = 0;
    dino.onGround = true;
    dino.jumpsLeft = dino.maxJumps;
  }

  // Screen wrapping
  if (dino.x < -DINO_SIZE) dino.x = W + DINO_SIZE;
  if (dino.x > W + DINO_SIZE) dino.x = -DINO_SIZE;

  // Star collection
  for (let i = stars.length - 1; i >= 0; i--) {
    const s = stars[i];
    const sy = s.y + Math.sin(s.phase) * s.bobAmount;
    const dx = dino.x - s.x;
    const dy = dino.y - sy;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < DINO_SIZE * 0.5 + STAR_SIZE * 0.5) {
      // Collected!
      spawnParticles(s.x, sy);
      playSfxCollect();
      stars.splice(i, 1);
      score++;

      if (score >= totalStars) {
        winGame();
        return;
      }

      // Spawn a new star
      spawnStar();
    }
  }

  // Animate star bobbing
  stars.forEach(s => {
    s.phase += s.bobSpeed;
  });

  // Move clouds
  clouds.forEach(c => {
    c.x += c.speed;
    if (c.x > W + 100) c.x = -100;
  });

  updateParticles();
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  drawBackground();
  drawGround();
  drawPlatforms();

  // Stars
  stars.forEach(s => {
    const sy = s.y + Math.sin(s.phase) * s.bobAmount;
    drawStar(s.x, sy, STAR_SIZE, s.phase);
  });

  // Dino
  drawDino(dino.x, dino.y, DINO_SIZE, dino.facingRight);

  // Particles
  drawParticles();

  // HUD
  document.getElementById('score-display').textContent = `‚≠ê ${score} / ${totalStars}`;
  document.getElementById('stars-left').textContent =
    `Catch ${totalStars - score} more star${totalStars - score !== 1 ? 's' : ''}!`;
}

function loop() {
  if (!gameRunning) return;
  update();
  draw();
  animFrame = requestAnimationFrame(loop);
}

// --- Input ---
window.addEventListener('keydown', e => {
  keysDown[e.key] = true;
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
    e.preventDefault();
  }
});

window.addEventListener('keyup', e => {
  keysDown[e.key] = false;
});

// ===== Mobile on-screen controls =====
function showMobileUI() {
  document.getElementById('mobile-controls').style.display = 'block';
  document.getElementById('instructions-desktop').style.display = 'none';
  document.getElementById('instructions-mobile').style.display = 'block';
}

if (isMobile) showMobileUI();

// Prevent all unwanted mobile browser behaviors
document.addEventListener('touchmove', e => {
  if (gameRunning) e.preventDefault();
}, { passive: false });

// Prevent double-tap zoom on iOS
let lastTouchEnd = 0;
document.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, { passive: false });

// ---- On-screen button handlers ----
function setupButton(id, keyName) {
  const btn = document.getElementById(id);

  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    e.stopPropagation();
    keysDown[keyName] = true;
    btn.classList.add('pressed');
  }, { passive: false });

  btn.addEventListener('touchend', e => {
    e.preventDefault();
    e.stopPropagation();
    keysDown[keyName] = false;
    btn.classList.remove('pressed');
  }, { passive: false });

  btn.addEventListener('touchcancel', e => {
    keysDown[keyName] = false;
    btn.classList.remove('pressed');
  });

  // Also clear if finger slides off button
  btn.addEventListener('touchleave', e => {
    keysDown[keyName] = false;
    btn.classList.remove('pressed');
  });
}

setupButton('btn-left', 'left');
setupButton('btn-right', 'right');
setupButton('btn-jump', 'up');

// Multi-touch: allow holding left/right AND tapping jump simultaneously
// We handle this by listening on the document for touches and mapping
// each active touch to the button it's over.
document.addEventListener('touchstart', e => {
  if (!gameRunning) return;
  // Prevent pull-to-refresh and overscroll
  if (e.target === canvas) e.preventDefault();
}, { passive: false });

// Fallback: if user touches directly on the canvas (not a button),
// use left-half/right-half for movement + tap to also jump
canvas.addEventListener('touchstart', e => {
  if (!gameRunning) return;
  e.preventDefault();
  for (const touch of e.changedTouches) {
    // If touch is in the lower control zone, ignore (buttons handle it)
    if (touch.clientY > H - 170) return;
    // Tap anywhere on canvas = jump
    keysDown['up'] = true;
    setTimeout(() => { keysDown['up'] = false; }, 100);
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
}, { passive: false });
</script>
</body>
</html>
